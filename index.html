<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ブロック崩し - プレイヤーを楽しませろ版</title>
  <style>
    :root {
      --bg: #0b0f1a;
      --panel: rgba(255,255,255,0.08);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --accent: #7dd3fc;
    }
    html, body { height: 100%; margin: 0; background: radial-gradient(1200px 800px at 70% 20%, #16223f 0%, var(--bg) 55%, #070a12 100%); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", Meiryo, sans-serif; }
    .wrap { display: grid; grid-template-rows: auto 1fr auto; height: 100%; }
    header, footer { padding: 12px 14px; display: flex; align-items: center; gap: 12px; }
    header { border-bottom: 1px solid rgba(255,255,255,0.10); background: rgba(0,0,0,0.15); backdrop-filter: blur(8px); }
    footer { border-top: 1px solid rgba(255,255,255,0.10); background: rgba(0,0,0,0.12); backdrop-filter: blur(8px); flex-wrap: wrap; }
    .title { font-weight: 700; letter-spacing: 0.02em; }
    .pill { padding: 6px 10px; border-radius: 999px; background: var(--panel); border: 1px solid rgba(255,255,255,0.10); color: var(--muted); font-size: 12px; display: inline-flex; align-items: center; gap: 8px; }
    .pill strong { color: var(--text); font-weight: 700; }
    .spacer { flex: 1; }
    .btn {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.16);
      background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));
      color: var(--text);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      cursor: pointer;
      user-select: none;
    }
    .btn:active { transform: translateY(1px); }
    .toggle { display: inline-flex; align-items: center; gap: 8px; }
    input[type="checkbox"] { width: 16px; height: 16px; accent-color: var(--accent); }
    main { display: grid; place-items: center; padding: 10px; }
    .stage {
      width: min(92vw, 980px);
      aspect-ratio: 4 / 3;
      position: relative;
      border-radius: 18px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 20px 70px rgba(0,0,0,0.45);
      background: rgba(0,0,0,0.20);
    }
    canvas { width: 100%; height: 100%; display: block; }
    .hud {
      position: absolute;
      inset: 12px 12px auto 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      pointer-events: none;
      flex-wrap: wrap;
    }
    .toast {
      position: absolute;
      inset: auto 12px 12px 12px;
      display: grid;
      gap: 8px;
      align-content: end;
      pointer-events: none;
    }
    .card {
      background: rgba(0,0,0,0.40);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 12px 14px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 40px rgba(0,0,0,0.35);
    }
    .card h2 { margin: 0 0 6px; font-size: 14px; }
    .card p { margin: 0; color: var(--muted); font-size: 12px; line-height: 1.5; }
    .kbd {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 6px;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--text);
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.02em;
      margin: 0 2px;
    }
    .sr { position: absolute; left: -9999px; width: 1px; height: 1px; overflow: hidden; }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="title">ブロック崩し</div>
    <div class="pill"><strong>コンセプト</strong> 手応え × テンポ × 不親切排除</div>
    <div class="spacer"></div>
    <button class="btn" id="btnRestart" title="Rでもいける">リスタート</button>
    <button class="btn" id="btnPause" title="Pでもいける">一時停止</button>
  </header>

  <main>
    <div class="stage">
      <canvas id="c" width="960" height="720" aria-label="ブロック崩しのゲーム画面"></canvas>
      <div class="hud" aria-hidden="true">
        <div class="pill">スコア <strong id="score">0</strong></div>
        <div class="pill">残機 <strong id="lives">3</strong></div>
        <div class="pill">レベル <strong id="level">1</strong></div>
        <div class="pill">倍率 <strong id="mult">1.0</strong></div>
        <div class="pill" id="buffs" style="display:none;">バフ <strong id="buffText">-</strong></div>
      </div>
      <div class="toast" aria-hidden="true">
        <div class="card" id="hintCard">
          <h2>操作</h2>
          <p>
            <span class="kbd">←</span><span class="kbd">→</span> or <span class="kbd">A</span><span class="kbd">D</span> / マウス・タッチで移動。
            <span class="kbd">Space</span>で開始。<span class="kbd">P</span>で停止。<span class="kbd">R</span>でリスタート。
          </p>
        </div>
        <div class="card" id="statusCard" style="display:none;">
          <h2 id="statusTitle">状態</h2>
          <p id="statusBody">テキスト</p>
        </div>
        <div class="card" id="msgCard" style="display:none;">
          <h2 id="msgTitle">アイテム</h2>
          <p id="msgBody">テキスト</p>
        </div>
      </div>
      <div class="sr" id="liveRegion" aria-live="polite"></div>
    </div>
  </main>

  <footer>
    <label class="toggle pill" title="音の優先度は高い。切りたきゃ切れ。">
      <input type="checkbox" id="togSound" checked />
      <span>サウンド</span>
    </label>
    <label class="toggle pill" title="目が疲れるなら切れ。">
      <input type="checkbox" id="togFlash" checked />
      <span>フラッシュ/ヒットストップ</span>
    </label>
    <label class="toggle pill" title="速さで気持ちよくなるタイプ向け。">
      <span>スピード</span>
      <select id="selSpeed" class="btn" style="padding:6px 10px;">
        <option value="0.9">0.9</option>
        <option value="1.0" selected>1.0</option>
        <option value="1.15">1.15</option>
        <option value="1.3">1.3</option>
      </select>
    </label>
    <div class="spacer"></div>
    <div class="pill"><span style="color:rgba(255,255,255,0.65);">哲学の要約:</span> 「苦労は忘れていい。ミスは残る。」</div>
  </footer>
</div>

<script>
(() => {
  "use strict";

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: true });

  const ui = {
    score: document.getElementById("score"),
    lives: document.getElementById("lives"),
    level: document.getElementById("level"),
    mult: document.getElementById("mult"),
    buffs: document.getElementById("buffs"),
    buffText: document.getElementById("buffText"),
    hintCard: document.getElementById("hintCard"),
    statusCard: document.getElementById("statusCard"),
    statusTitle: document.getElementById("statusTitle"),
    statusBody: document.getElementById("statusBody"),
    msgCard: document.getElementById("msgCard"),
    msgTitle: document.getElementById("msgTitle"),
    msgBody: document.getElementById("msgBody"),
    liveRegion: document.getElementById("liveRegion"),
    btnRestart: document.getElementById("btnRestart"),
    btnPause: document.getElementById("btnPause"),
    togSound: document.getElementById("togSound"),
    togFlash: document.getElementById("togFlash"),
    selSpeed: document.getElementById("selSpeed"),
  };

  function fitCanvas() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = 960, h = 720;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  fitCanvas();
  window.addEventListener("resize", fitCanvas);

  // ===== Audio =====
  let audioCtx = null;
  const audioState = { enabled: true, master: null, limiter: null };

  function ensureAudio() {
    if (!audioState.enabled) return;
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    audioState.master = audioCtx.createGain();
    audioState.master.gain.value = 0.65;

    audioState.limiter = audioCtx.createDynamicsCompressor();
    audioState.limiter.threshold.value = -12;
    audioState.limiter.knee.value = 20;
    audioState.limiter.ratio.value = 8;
    audioState.limiter.attack.value = 0.003;
    audioState.limiter.release.value = 0.08;

    audioState.master.connect(audioState.limiter);
    audioState.limiter.connect(audioCtx.destination);
  }

  function beep({ freq = 440, dur = 0.06, type = "square", gain = 0.14, attack = 0.004, release = 0.04 } = {}) {
    if (!audioState.enabled) return;
    ensureAudio();
    if (!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.linearRampToValueAtTime(gain, t0 + attack);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur + release);
    osc.connect(g);
    g.connect(audioState.master);
    osc.start(t0);
    osc.stop(t0 + dur + release + 0.01);
  }

  function noiseHit({ dur = 0.05, gain = 0.10 } = {}) {
    if (!audioState.enabled) return;
    ensureAudio();
    if (!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const bufferSize = Math.max(1, Math.floor(audioCtx.sampleRate * dur));
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      const env = 1 - i / bufferSize;
      data[i] = (Math.random() * 2 - 1) * env;
    }
    const src = audioCtx.createBufferSource();
    src.buffer = buffer;
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(gain, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    src.connect(g);
    g.connect(audioState.master);
    src.start(t0);
    src.stop(t0 + dur + 0.01);
  }

  const SFX = {
    brick() { noiseHit({ dur: 0.05, gain: 0.14 }); beep({ freq: 880, dur: 0.04, type: "square", gain: 0.10 }); },
    paddle() { beep({ freq: 520, dur: 0.04, type: "triangle", gain: 0.08 }); },
    wall() { beep({ freq: 320, dur: 0.03, type: "sine", gain: 0.06 }); },
    lose() { beep({ freq: 140, dur: 0.10, type: "sawtooth", gain: 0.12, attack: 0.002, release: 0.08 }); },
    win() { beep({ freq: 660, dur: 0.06, type: "triangle", gain: 0.10 }); setTimeout(() => beep({ freq: 990, dur: 0.07, type: "triangle", gain: 0.10 }), 90); },
    item() { beep({ freq: 740, dur: 0.05, type: "triangle", gain: 0.10 }); setTimeout(() => beep({ freq: 1040, dur: 0.06, type: "triangle", gain: 0.10 }), 60); }
  };

  // ===== Game constants =====
  const W = 960, H = 720;
  const STEP = 1/60;

  // ===== State =====
  const state = {
    running: false,
    paused: false,
    gameOver: false,
    level: 1,
    score: 0,
    lives: 3,
    mult: 1.0,
    speedMul: 1.0,
    startedOnce: false,

    flashEnabled: true,
    flash: 0,
    shake: 0,
    hitStop: 0,

    respawnLock: 0,
    itemPity: 0,

    keys: new Set(),
    pointerX: null,
    pointerActive: false,

    lastTs: 0,
    acc: 0,
  };

  const paddle = {
    baseW: 140,
    w: 140,
    h: 16,
    x: W/2,
    y: H - 70,
    vx: 0,
    speed: 820,
  };

  const ball = {
    r: 9,
    x: W/2,
    y: H - 90,
    vx: 280,
    vy: -420,
    speed: 520,
    stuck: true,
  };

  const effects = { wide: 0, slow: 0, pierce: 0 };
  const powerups = [];

  const ITEM = {
    WIDE:   { key: "WIDE",   name: "ワイド", desc: "パドル拡大(15秒)", color: "rgba(134,239,172,0.95)", tag: "W" },
    SLOW:   { key: "SLOW",   name: "スロー", desc: "ボール減速(10秒)", color: "rgba(253,224,71,0.95)",  tag: "S" },
    PIERCE: { key: "PIERCE", name: "貫通",   desc: "ブロック貫通(8秒)",  color: "rgba(196,181,253,0.95)", tag: "P" },
    LIFE:   { key: "LIFE",   name: "1UP",    desc: "残機+1(上限5)",      color: "rgba(125,211,252,0.95)", tag: "+1" },
  };

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function length(vx, vy) { return Math.hypot(vx, vy); }

  function normalizeBallSpeed(target) {
    const sp = length(ball.vx, ball.vy);
    if (sp < 1e-3) return;
    const mul = target / sp;
    ball.vx *= mul;
    ball.vy *= mul;
  }

  function resetBall(stuck = true) {
    ball.stuck = stuck;
    ball.x = paddle.x;
    ball.y = paddle.y - paddle.h/2 - ball.r - 2;
    const dir = (Math.random() < 0.5 ? -1 : 1);
    ball.vx = 260 * dir;
    ball.vy = -440;
  }

  // ===== Bricks =====
  const bricks = {
    cols: 11,
    rows: 6,
    pad: 10,
    top: 90,
    left: 60,
    w: 72,
    h: 24,
    list: [],
  };

  function makeLevel(lv) {
    bricks.list.length = 0;
    const rows = bricks.rows + Math.min(2, Math.floor((lv-1)/2));
    const cols = bricks.cols;
    const colors = [
      [0.15, 0.6, 0.95],
      [0.2,  0.9, 0.65],
      [0.95, 0.75,0.25],
      [0.98, 0.45,0.55],
      [0.75, 0.55,0.98],
      [0.35, 0.85,0.98],
      [0.95, 0.95,0.95],
    ];
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const mask = (r + lv) % 2 === 0 ? 1 : 0;
        if (mask && (c === 0 || c === cols-1) && r < 2) continue;
        const hp = 1 + Math.floor((lv-1)/3) + (r >= rows-2 ? 1 : 0);
        const col = colors[(r + lv) % colors.length];
        bricks.list.push({
          x: bricks.left + c * (bricks.w + bricks.pad),
          y: bricks.top + r * (bricks.h + bricks.pad),
          w: bricks.w, h: bricks.h,
          hp, hpMax: hp,
          col,
          alive: true,
          pop: 0,
        });
      }
    }
    powerups.length = 0;
    state.itemPity = 0;
  }

  // ===== UX =====
  function announce(msg) { ui.liveRegion.textContent = msg; }
  function setStatus(title, body) {
    ui.statusTitle.textContent = title;
    ui.statusBody.textContent = body;
    ui.statusCard.style.display = "block";
  }
  function clearStatus() { ui.statusCard.style.display = "none"; }

  let msgTimer = 0;
  function showMsg(title, body, ms = 1200) {
    ui.msgTitle.textContent = title;
    ui.msgBody.textContent = body;
    ui.msgCard.style.display = "block";
    msgTimer = ms/1000;
  }
  function hideMsg() { ui.msgCard.style.display = "none"; msgTimer = 0; }

  function syncUI() {
    ui.score.textContent = String(Math.floor(state.score));
    ui.lives.textContent = String(state.lives);
    ui.level.textContent = String(state.level);
    ui.mult.textContent = state.mult.toFixed(1);

    const tags = [];
    if (effects.wide > 0) tags.push("ワイド");
    if (effects.slow > 0) tags.push("スロー");
    if (effects.pierce > 0) tags.push("貫通");
    if (tags.length) {
      ui.buffs.style.display = "inline-flex";
      ui.buffText.textContent = tags.join(" / ");
    } else {
      ui.buffs.style.display = "none";
    }
  }

  function hitFeedback(intensity = 1.0) {
    if (!state.flashEnabled) return;
    state.flash = clamp(state.flash + 0.6 * intensity, 0, 1);
    state.shake = clamp(state.shake + 5 * intensity, 0, 10);
    state.hitStop = clamp(state.hitStop + 0.03 * intensity, 0, 0.09);
  }

  // ===== Restart =====
  function restart(all = true) {
    state.running = true;
    state.paused = false;
    state.gameOver = false;
    state.flash = 0;
    state.shake = 0;
    state.hitStop = 0;
    state.respawnLock = 0;
    state.itemPity = 0;

    state.mult = 1.0;
    state.speedMul = parseFloat(ui.selSpeed.value || "1.0");

    effects.wide = 0; effects.slow = 0; effects.pierce = 0;
    paddle.w = paddle.baseW;
    powerups.length = 0;

    if (all) {
      state.level = 1;
      state.score = 0;
      state.lives = 3;
    }

    makeLevel(state.level);
    paddle.x = W/2;
    paddle.vx = 0;
    resetBall(true);

    ui.hintCard.style.display = state.startedOnce ? "none" : "block";
    clearStatus();
    hideMsg();
    syncUI();
    announce("リスタート");
  }

  // ===== Input =====
  function pointerToWorld(clientX) {
    const rect = canvas.getBoundingClientRect();
    const nx = (clientX - rect.left) / rect.width;
    return clamp(nx * W, 0, W);
  }

  function userStart() {
    if (!state.running) state.running = true;
    state.startedOnce = true;
    ui.hintCard.style.display = "none";

    if (state.gameOver) return;

    if (state.paused) {
      clearStatus();
      state.paused = false;
      announce("再開");
    }

    if (ball.stuck) {
      state.respawnLock = 0;
      ball.stuck = false;
      normalizeBallSpeed(ball.speed * 1.02);
      announce("開始");
      if (audioCtx && audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
    }
  }

  function togglePause() {
    if (!state.running || state.gameOver) return;
    state.paused = !state.paused;
    if (state.paused) { setStatus("一時停止", "Spaceで再開。"); announce("一時停止"); }
    else { clearStatus(); announce("再開"); if (audioCtx && audioCtx.state === "suspended") audioCtx.resume().catch(()=>{}); }
  }

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (["arrowleft","arrowright","a","d","p","r"," ","space"].includes(k) || e.code === "Space") e.preventDefault();
    state.keys.add(k);

    if (e.code === "Space" || k === " " || k === "space") userStart();
    else if (k === "p") togglePause();
    else if (k === "r") restart(state.gameOver || state.lives <= 0);
  }, { passive: false });

  window.addEventListener("keyup", (e) => {
    state.keys.delete(e.key.toLowerCase());
  });

  function onPointerDown(e) {
    state.pointerActive = true;
    const x = (e.touches ? e.touches[0].clientX : e.clientX);
    state.pointerX = pointerToWorld(x);
    userStart();
  }
  function onPointerMove(e) {
    if (!state.pointerActive && !e.touches) return;
    const x = (e.touches ? e.touches[0].clientX : e.clientX);
    state.pointerX = pointerToWorld(x);
  }
  function onPointerUp() { state.pointerActive = false; state.pointerX = null; }

  canvas.addEventListener("mousedown", onPointerDown);
  window.addEventListener("mousemove", onPointerMove);
  window.addEventListener("mouseup", onPointerUp);
  canvas.addEventListener("touchstart", onPointerDown, { passive: false });
  window.addEventListener("touchmove", onPointerMove, { passive: false });
  window.addEventListener("touchend", onPointerUp);

  ui.togSound.addEventListener("change", () => {
    audioState.enabled = !!ui.togSound.checked;
    if (audioState.enabled) ensureAudio();
  });
  ui.togFlash.addEventListener("change", () => {
    state.flashEnabled = !!ui.togFlash.checked;
  });
  ui.selSpeed.addEventListener("change", () => {
    state.speedMul = parseFloat(ui.selSpeed.value || "1.0");
    syncUI();
  });

  ui.btnRestart.addEventListener("click", () => restart(state.gameOver || state.lives <= 0));
  ui.btnPause.addEventListener("click", () => togglePause());

  // ===== Collision =====
  function rectCircleCollide(rx, ry, rw, rh, cx, cy, cr) {
    const px = clamp(cx, rx, rx + rw);
    const py = clamp(cy, ry, ry + rh);
    const dx = cx - px, dy = cy - py;
    return (dx*dx + dy*dy) <= cr*cr;
  }
  function rectRectCollide(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function resolveBrickCollision(b) {
    const cx = ball.x, cy = ball.y;
    const prevX = cx - ball.vx * STEP, prevY = cy - ball.vy * STEP;
    const bx = b.x, by = b.y, bw = b.w, bh = b.h;

    const fromLeft = prevX <= bx - ball.r;
    const fromRight = prevX >= bx + bw + ball.r;
    const fromTop = prevY <= by - ball.r;
    const fromBottom = prevY >= by + bh + ball.r;

    if ((fromLeft && !fromRight) || (fromRight && !fromLeft)) ball.vx *= -1;
    else if ((fromTop && !fromBottom) || (fromBottom && !fromTop)) ball.vy *= -1;
    else {
      const dx = (cx - (bx + bw/2)) / (bw/2);
      const dy = (cy - (by + bh/2)) / (bh/2);
      if (Math.abs(dx) > Math.abs(dy)) ball.vx *= -1;
      else ball.vy *= -1;
    }
  }

  function handlePaddleCollision() {
    const rx = paddle.x - paddle.w/2;
    const ry = paddle.y - paddle.h/2;
    if (!rectCircleCollide(rx, ry, paddle.w, paddle.h, ball.x, ball.y, ball.r)) return false;

    const hitX = (ball.x - paddle.x) / (paddle.w/2);
    const angle = clamp(hitX, -1, 1) * (Math.PI * 0.36);
    const sp = Math.max(ball.speed * 0.90, length(ball.vx, ball.vy));
    ball.vx = sp * Math.sin(angle);
    ball.vy = -Math.abs(sp * Math.cos(angle));
    ball.y = ry - ball.r - 0.5;

    state.mult = clamp(state.mult + 0.05, 1.0, 2.0);
    SFX.paddle();
    hitFeedback(0.8);
    return true;
  }

  // ===== Items =====
  function pickItemType() {
    const r = Math.random();
    if (r < 0.40) return ITEM.WIDE;
    if (r < 0.68) return ITEM.SLOW;
    if (r < 0.88) return ITEM.PIERCE;
    return ITEM.LIFE;
  }

  function spawnItemFromBrick(b) {
    state.itemPity += 1;
    const base = 0.35;
    const chance = Math.min(0.55, base + state.level * 0.03);
    const force = (state.itemPity >= 8);

    if (!force && Math.random() > chance) return;

    state.itemPity = 0;
    const it = pickItemType();
    powerups.push({
      x: b.x + b.w/2,
      y: b.y + b.h/2,
      vy: 210 + state.level * 10,
      w: 44,
      h: 18,
      type: it.key,
      alive: true,
      bob: Math.random() * Math.PI * 2,
    });
  }

  function applyItem(typeKey) {
    const it = ITEM[typeKey];
    if (!it) return;

    if (typeKey === "WIDE") effects.wide = Math.max(effects.wide, 15);
    if (typeKey === "SLOW") effects.slow = Math.max(effects.slow, 10);
    if (typeKey === "PIERCE") effects.pierce = Math.max(effects.pierce, 8);
    if (typeKey === "LIFE") state.lives = clamp(state.lives + 1, 0, 5);

    SFX.item();
    hitFeedback(0.6);
    showMsg("アイテム獲得", it.name + "： " + it.desc);
    announce("アイテム " + it.name);
    syncUI();
  }

  // ===== Progression =====
  function nextLevel() {
    state.level += 1;
    state.mult = clamp(state.mult + 0.15, 1.0, 2.0);
    makeLevel(state.level);
    resetBall(true);
    state.paused = true;
    setStatus("レベル " + state.level, "Spaceで開始。");
    announce("レベルアップ");
    SFX.win();
    syncUI();
  }

  function loseLife() {
    if (state.gameOver) return;
    if (state.respawnLock > 0) return;
    state.respawnLock = 0.7;

    state.lives = Math.max(0, state.lives - 1);
    state.mult = 1.0;
    SFX.lose();
    hitFeedback(1.2);

    state.paused = true;

    if (state.lives <= 0) {
      state.gameOver = true;
      state.score = 0; // 要望どおり
      setStatus("ゲームオーバー", "Rで最初から。スコアは0に戻した。");
      announce("ゲームオーバー");
    } else {
      resetBall(true);
      setStatus("落下", "残機 " + state.lives + "。Spaceで再開。");
      announce("残機減少");
    }
    syncUI();
  }

  // ===== Update =====
  function update(dt) {
    if (!state.running) return;

    if (msgTimer > 0) {
      msgTimer = Math.max(0, msgTimer - dt);
      if (msgTimer === 0) hideMsg();
    }

    if (state.respawnLock > 0) state.respawnLock = Math.max(0, state.respawnLock - dt);

    effects.wide = Math.max(0, effects.wide - dt);
    effects.slow = Math.max(0, effects.slow - dt);
    effects.pierce = Math.max(0, effects.pierce - dt);
    paddle.w = paddle.baseW * (effects.wide > 0 ? 1.35 : 1.0);

    if (state.paused) {
      state.flash = Math.max(0, state.flash - dt * 2.0);
      state.shake = Math.max(0, state.shake - dt * 20);
      return;
    }

    if (state.hitStop > 0) {
      state.hitStop = Math.max(0, state.hitStop - dt);
      state.flash = Math.max(0, state.flash - dt * 2.0);
      state.shake = Math.max(0, state.shake - dt * 20);
      return;
    }

    const sm = state.speedMul;

    // Paddle input
    let dir = 0;
    if (state.keys.has("arrowleft") || state.keys.has("a")) dir -= 1;
    if (state.keys.has("arrowright") || state.keys.has("d")) dir += 1;

    const desired = dir * paddle.speed;
    if (state.pointerX != null) {
      const dx = state.pointerX - paddle.x;
      paddle.vx = clamp(dx * 10, -paddle.speed * 1.4, paddle.speed * 1.4);
    } else {
      paddle.vx += (desired - paddle.vx) * clamp(dt * 12, 0, 1);
    }
    paddle.x += paddle.vx * dt * sm;
    paddle.x = clamp(paddle.x, paddle.w/2, W - paddle.w/2);

    // Ball
    if (ball.stuck) {
      ball.x = paddle.x;
      ball.y = paddle.y - paddle.h/2 - ball.r - 2;
      state.mult = Math.max(1.0, state.mult - dt * 0.12);
      syncUI();
      return;
    }

    const slowMul = (effects.slow > 0 ? 0.78 : 1.0);
    const targetSpeed = (ball.speed + state.level * 12) * sm * slowMul;
    normalizeBallSpeed(targetSpeed);

    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;

    // Walls
    if (ball.x - ball.r <= 0) { ball.x = ball.r; ball.vx *= -1; SFX.wall(); hitFeedback(0.35); }
    else if (ball.x + ball.r >= W) { ball.x = W - ball.r; ball.vx *= -1; SFX.wall(); hitFeedback(0.35); }
    if (ball.y - ball.r <= 0) { ball.y = ball.r; ball.vy *= -1; SFX.wall(); hitFeedback(0.35); }

    // Bottom
    if (state.respawnLock === 0 && (ball.y - ball.r > H + 40)) {
      loseLife();
      return;
    }

    handlePaddleCollision();

    // Bricks
    let aliveCount = 0;
    for (const b of bricks.list) {
      if (!b.alive) continue;
      aliveCount++;

      if (rectCircleCollide(b.x, b.y, b.w, b.h, ball.x, ball.y, ball.r)) {
        if (effects.pierce <= 0) resolveBrickCollision(b);
        b.hp -= 1;
        b.pop = 1.0;

        SFX.brick();
        hitFeedback(1.0);

        const base = 120;
        state.score += base * state.mult * (1 + 0.1 * (b.hpMax - 1));
        state.mult = clamp(state.mult + 0.02, 1.0, 2.0);

        if (b.hp <= 0) {
          b.alive = false;
          state.score += 80 * state.mult;
          spawnItemFromBrick(b);
        }

        if (effects.pierce > 0) {
          const sp = length(ball.vx, ball.vy);
          if (sp > 1e-3) { ball.x += (ball.vx / sp) * 4; ball.y += (ball.vy / sp) * 4; }
        }

        syncUI();
        break;
      }
    }

    // Items update
    const prx = paddle.x - paddle.w/2, pry = paddle.y - paddle.h/2;
    for (const p of powerups) {
      if (!p.alive) continue;
      p.bob += dt * 6;
      p.y += p.vy * dt;
      const x = p.x - p.w/2;
      const y = p.y - p.h/2 + Math.sin(p.bob) * 2;

      if (rectRectCollide(x, y, p.w, p.h, prx, pry, paddle.w, paddle.h)) {
        p.alive = false;
        applyItem(p.type);
      } else if (p.y - p.h/2 > H + 30) {
        p.alive = false;
      }
    }
    for (let i = powerups.length - 1; i >= 0; i--) if (!powerups[i].alive) powerups.splice(i, 1);

    if (aliveCount === 0) nextLevel();

    // decay
    state.flash = Math.max(0, state.flash - dt * 2.0);
    state.shake = Math.max(0, state.shake - dt * 20);
    state.mult = Math.max(1.0, state.mult - dt * 0.05);
    syncUI();
  }

  // ===== Render =====
  function roundRect(x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  function drawBackground() {
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.20)";
    ctx.fillRect(0, 0, W, H);

    ctx.globalAlpha = 0.22;
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 1;
    const step = 40;
    for (let x = 0; x <= W; x += step) { ctx.beginPath(); ctx.moveTo(x + 0.5, 0); ctx.lineTo(x + 0.5, H); ctx.stroke(); }
    for (let y = 0; y <= H; y += step) { ctx.beginPath(); ctx.moveTo(0, y + 0.5); ctx.lineTo(W, y + 0.5); ctx.stroke(); }
    ctx.globalAlpha = 1;

    const g = ctx.createLinearGradient(0, 0, 0, 220);
    g.addColorStop(0, "rgba(125, 211, 252, 0.18)");
    g.addColorStop(1, "rgba(0,0,0,0.0)");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, 260);

    const v = ctx.createRadialGradient(W/2, H/2, 120, W/2, H/2, 560);
    v.addColorStop(0, "rgba(0,0,0,0.0)");
    v.addColorStop(1, "rgba(0,0,0,0.55)");
    ctx.fillStyle = v;
    ctx.fillRect(0, 0, W, H);
    ctx.restore();
  }

  function drawBricks() {
    ctx.save();
    for (const b of bricks.list) {
      if (!b.alive) continue;
      const pop = b.pop;
      b.pop = Math.max(0, b.pop - STEP * 6);
      const scale = 1 + pop * 0.08;
      const cx = b.x + b.w/2, cy = b.y + b.h/2;
      const w = b.w * scale, h = b.h * scale;
      const x = cx - w/2, y = cy - h/2;

      const t = b.hp / b.hpMax;
      const [r,g,bl] = b.col;
      const fill = `rgba(${Math.floor(r*255)},${Math.floor(g*255)},${Math.floor(bl*255)},0.86)`;

      ctx.shadowColor = `rgba(${Math.floor(r*255)},${Math.floor(g*255)},${Math.floor(bl*255)},0.35)`;
      ctx.shadowBlur = 14;

      ctx.fillStyle = fill;
      roundRect(x, y, w, h, 9);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.lineWidth = 1;
      roundRect(x + 0.5, y + 0.5, w - 1, h - 1, 9);
      ctx.stroke();

      if (b.hpMax > 1) {
        ctx.fillStyle = "rgba(0,0,0,0.25)";
        ctx.fillRect(x + 10, y + h - 8, w - 20, 3);
        ctx.fillStyle = "rgba(255,255,255,0.65)";
        ctx.fillRect(x + 10, y + h - 8, (w - 20) * t, 3);
      }
    }
    ctx.restore();
  }

  function drawItems() {
    if (!powerups.length) return;
    ctx.save();
    ctx.font = "700 12px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    for (const p of powerups) {
      if (!p.alive) continue;
      const it = ITEM[p.type];
      const x = p.x - p.w/2;
      const y = p.y - p.h/2 + Math.sin(p.bob) * 2;

      ctx.shadowColor = "rgba(0,0,0,0.35)";
      ctx.shadowBlur = 10;
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      roundRect(x, y, p.w, p.h, 999);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.fillStyle = it.color;
      roundRect(x + 1, y + 1, p.w - 2, p.h - 2, 999);
      ctx.fill();

      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.lineWidth = 1;
      roundRect(x + 0.5, y + 0.5, p.w - 1, p.h - 1, 999);
      ctx.stroke();

      ctx.fillStyle = "rgba(0,0,0,0.65)";
      ctx.fillText(it.tag, p.x, y + p.h/2 + 0.5);
    }
    ctx.restore();
  }

  function drawPaddle() {
    const x = paddle.x - paddle.w/2;
    const y = paddle.y - paddle.h/2;

    ctx.save();
    ctx.shadowColor = "rgba(125,211,252,0.40)";
    ctx.shadowBlur = 18;
    ctx.fillStyle = "rgba(125,211,252,0.30)";
    roundRect(x, y, paddle.w, paddle.h, 10);
    ctx.fill();

    ctx.shadowBlur = 0;
    const g = ctx.createLinearGradient(0, y, 0, y + paddle.h);
    g.addColorStop(0, "rgba(255,255,255,0.22)");
    g.addColorStop(1, "rgba(255,255,255,0.08)");
    ctx.fillStyle = g;
    roundRect(x, y, paddle.w, paddle.h, 10);
    ctx.fill();

    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 1;
    roundRect(x + 0.5, y + 0.5, paddle.w - 1, paddle.h - 1, 10);
    ctx.stroke();
    ctx.restore();
  }

  function drawBall() {
    ctx.save();
    ctx.shadowColor = "rgba(255,255,255,0.55)";
    ctx.shadowBlur = 18;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.arc(ball.x - ball.r*0.35, ball.y - ball.r*0.35, ball.r*0.35, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(125,211,252,0.75)";
    ctx.fill();
    ctx.restore();
  }

  function drawCenterText() {
    if (state.paused || state.gameOver) return;
    if (ball.stuck) {
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.86)";
      ctx.font = "700 28px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Space / クリックで開始", W/2, H/2 - 10);

      ctx.fillStyle = "rgba(255,255,255,0.62)";
      ctx.font = "500 14px system-ui, sans-serif";
      ctx.fillText("不親切を作るくらいなら、ここで始め方を出す。", W/2, H/2 + 18);
      ctx.restore();
    }
  }

  function drawOverlay() {
    if (state.flashEnabled && state.flash > 0.001) {
      ctx.save();
      ctx.globalAlpha = state.flash * 0.45;
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, W, H);
      ctx.restore();
    }
  }

  function render() {
    const sx = (state.flashEnabled ? (Math.random()*2-1) * state.shake : 0);
    const sy = (state.flashEnabled ? (Math.random()*2-1) * state.shake : 0);

    ctx.save();
    ctx.clearRect(0, 0, W, H);
    ctx.translate(sx, sy);

    drawBackground();
    drawBricks();
    drawItems();
    drawPaddle();
    drawBall();
    drawCenterText();

    ctx.restore();
    drawOverlay();
  }

  // ===== Loop =====
  function frame(ts) {
    if (!state.lastTs) state.lastTs = ts;
    const dt = Math.min(0.05, (ts - state.lastTs) / 1000);
    state.lastTs = ts;
    state.acc += dt;

    while (state.acc >= STEP) {
      update(STEP);
      state.acc -= STEP;
    }
    render();
    requestAnimationFrame(frame);
  }

  function init() {
    state.flashEnabled = !!ui.togFlash.checked;
    audioState.enabled = !!ui.togSound.checked;
    state.speedMul = parseFloat(ui.selSpeed.value || "1.0");

    restart(true);
    setStatus("準備完了", "Spaceで開始。");
    state.paused = true;

    requestAnimationFrame(frame);
  }

  init();
})();
</script>
</body>
</html>
