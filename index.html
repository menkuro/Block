<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ブロック崩し - プレイヤーを楽しませろ版</title>
  <style>
    :root {
      --bg: #0b0f1a;
      --panel: rgba(255,255,255,0.08);
      --panel2: rgba(255,255,255,0.12);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --accent: #7dd3fc;
      --danger: #fb7185;
    }
    html, body { height: 100%; margin: 0; background: radial-gradient(1200px 800px at 70% 20%, #16223f 0%, var(--bg) 55%, #070a12 100%); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", Meiryo, sans-serif; }
    .wrap { display: grid; grid-template-rows: auto 1fr auto; height: 100%; }
    header, footer { padding: 12px 14px; display: flex; align-items: center; gap: 12px; }
    header { border-bottom: 1px solid rgba(255,255,255,0.10); background: rgba(0,0,0,0.15); backdrop-filter: blur(8px); }
    footer { border-top: 1px solid rgba(255,255,255,0.10); background: rgba(0,0,0,0.12); backdrop-filter: blur(8px); flex-wrap: wrap; }
    .title { font-weight: 700; letter-spacing: 0.02em; }
    .pill { padding: 6px 10px; border-radius: 999px; background: var(--panel); border: 1px solid rgba(255,255,255,0.10); color: var(--muted); font-size: 12px; display: inline-flex; align-items: center; gap: 8px; }
    .pill strong { color: var(--text); font-weight: 700; }
    .spacer { flex: 1; }
    .btn {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.16);
      background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));
      color: var(--text);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      cursor: pointer;
      user-select: none;
    }
    .btn:active { transform: translateY(1px); }
    .toggle { display: inline-flex; align-items: center; gap: 8px; }
    input[type="checkbox"] { width: 16px; height: 16px; accent-color: var(--accent); }
    main { display: grid; place-items: center; padding: 10px; }
    .stage {
      width: min(92vw, 980px);
      aspect-ratio: 4 / 3;
      position: relative;
      border-radius: 18px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 20px 70px rgba(0,0,0,0.45);
      background: rgba(0,0,0,0.20);
    }
    canvas { width: 100%; height: 100%; display: block; }
    .hud {
      position: absolute;
      inset: 12px 12px auto 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      pointer-events: none;
      flex-wrap: wrap;
    }
    .hud .pill { pointer-events: none; }
    .toast {
      position: absolute;
      inset: auto 12px 12px 12px;
      display: grid;
      gap: 8px;
      align-content: end;
      pointer-events: none;
    }
    .card {
      background: rgba(0,0,0,0.40);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 12px 14px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 40px rgba(0,0,0,0.35);
    }
    .card h2 { margin: 0 0 6px; font-size: 14px; }
    .card p { margin: 0; color: var(--muted); font-size: 12px; line-height: 1.5; }
    .kbd {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 6px;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--text);
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.02em;
      margin: 0 2px;
    }
    .danger { color: var(--danger); }
    .sr { position: absolute; left: -9999px; width: 1px; height: 1px; overflow: hidden; }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="title">ブロック崩し</div>
    <div class="pill"><strong>コンセプト</strong> 手応え × テンポ × 不親切排除</div>
    <div class="spacer"></div>
    <button class="btn" id="btnRestart" title="Rでもいける">リスタート</button>
    <button class="btn" id="btnPause" title="Pでもいける">一時停止</button>
  </header>

  <main>
    <div class="stage" id="stage">
      <canvas id="c" width="960" height="720" aria-label="ブロック崩しのゲーム画面"></canvas>
      <div class="hud" aria-hidden="true">
        <div class="pill">スコア <strong id="score">0</strong></div>
        <div class="pill">残機 <strong id="lives">3</strong></div>
        <div class="pill">レベル <strong id="level">1</strong></div>
        <div class="pill">倍率 <strong id="mult">1.0</strong></div>
      </div>
      <div class="toast" aria-hidden="true">
        <div class="card" id="hintCard">
          <h2>操作</h2>
          <p>
            <span class="kbd">←</span><span class="kbd">→</span> or <span class="kbd">A</span><span class="kbd">D</span> / マウス・タッチでパドル移動。
            <span class="kbd">Space</span>で開始。<span class="kbd">P</span>で停止。<span class="kbd">R</span>で再開。
          </p>
        </div>
        <div class="card" id="statusCard" style="display:none;">
          <h2 id="statusTitle">状態</h2>
          <p id="statusBody">テキスト</p>
        </div>
      </div>
      <div class="sr" id="liveRegion" aria-live="polite"></div>
    </div>
  </main>

  <footer>
    <label class="toggle pill" title="音の優先度は高い。なのに切りたがる人間は多い。">
      <input type="checkbox" id="togSound" checked />
      <span>サウンド</span>
    </label>
    <label class="toggle pill" title="目が疲れるなら切れ。ゲームは拷問じゃない。">
      <input type="checkbox" id="togFlash" checked />
      <span>フラッシュ/ヒットストップ</span>
    </label>
    <label class="toggle pill" title="速さで気持ちよくなるタイプ向け。">
      <span>スピード</span>
      <select id="selSpeed" class="btn" style="padding:6px 10px;">
        <option value="0.9">0.9</option>
        <option value="1.0" selected>1.0</option>
        <option value="1.15">1.15</option>
        <option value="1.3">1.3</option>
      </select>
    </label>
    <div class="spacer"></div>
    <div class="pill"><span style="color:var(--muted);">哲学の要約:</span> 「苦労は忘れていい。ミスは残る。」</div>
  </footer>
</div>

<script>
(() => {
  "use strict";

  // ===== Canvas / HiDPI =====
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: true });
  const stage = document.getElementById("stage");

  const ui = {
    score: document.getElementById("score"),
    lives: document.getElementById("lives"),
    level: document.getElementById("level"),
    mult: document.getElementById("mult"),
    hintCard: document.getElementById("hintCard"),
    statusCard: document.getElementById("statusCard"),
    statusTitle: document.getElementById("statusTitle"),
    statusBody: document.getElementById("statusBody"),
    liveRegion: document.getElementById("liveRegion"),
    btnRestart: document.getElementById("btnRestart"),
    btnPause: document.getElementById("btnPause"),
    togSound: document.getElementById("togSound"),
    togFlash: document.getElementById("togFlash"),
    selSpeed: document.getElementById("selSpeed"),
  };

  function fitCanvas() {
    // CSSで伸縮。内部解像度は固定でOK。必要ならここでDPR調整。
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = 960, h = 720;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  fitCanvas();
  window.addEventListener("resize", fitCanvas);

  // ===== Minimal Audio (WebAudio) =====
  // 重要: 「撃墜音」(ブロック破壊) > ヒット音 > ボイス(ない)
  let audioCtx = null;
  const audioState = {
    enabled: true,
    master: null,
    limiter: null,
  };

  function ensureAudio() {
    if (!audioState.enabled) return;
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    audioState.master = audioCtx.createGain();
    audioState.master.gain.value = 0.65;

    // 簡易リミッター風: DynamicsCompressor
    audioState.limiter = audioCtx.createDynamicsCompressor();
    audioState.limiter.threshold.value = -12;
    audioState.limiter.knee.value = 20;
    audioState.limiter.ratio.value = 8;
    audioState.limiter.attack.value = 0.003;
    audioState.limiter.release.value = 0.08;

    audioState.master.connect(audioState.limiter);
    audioState.limiter.connect(audioCtx.destination);
  }

  function beep({ freq = 440, dur = 0.06, type = "square", gain = 0.14, attack = 0.004, release = 0.04 } = {}) {
    if (!audioState.enabled) return;
    ensureAudio();
    if (!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.linearRampToValueAtTime(gain, t0 + attack);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur + release);
    osc.connect(g);
    g.connect(audioState.master);
    osc.start(t0);
    osc.stop(t0 + dur + release + 0.01);
  }

  function noiseHit({ dur = 0.05, gain = 0.10 } = {}) {
    if (!audioState.enabled) return;
    ensureAudio();
    if (!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const bufferSize = Math.max(1, Math.floor(audioCtx.sampleRate * dur));
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      // 短いノイズ。アタック強めで残響少なめ。
      const env = 1 - i / bufferSize;
      data[i] = (Math.random() * 2 - 1) * env;
    }
    const src = audioCtx.createBufferSource();
    src.buffer = buffer;
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(gain, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    src.connect(g);
    g.connect(audioState.master);
    src.start(t0);
    src.stop(t0 + dur + 0.01);
  }

  const SFX = {
    brick() { // 撃墜音（最重要）
      noiseHit({ dur: 0.05, gain: 0.14 });
      beep({ freq: 880, dur: 0.04, type: "square", gain: 0.10 });
    },
    paddle() { // ヒット音
      beep({ freq: 520, dur: 0.04, type: "triangle", gain: 0.08 });
    },
    wall() {
      beep({ freq: 320, dur: 0.03, type: "sine", gain: 0.06 });
    },
    lose() {
      beep({ freq: 140, dur: 0.10, type: "sawtooth", gain: 0.12, attack: 0.002, release: 0.08 });
    },
    win() {
      beep({ freq: 660, dur: 0.06, type: "triangle", gain: 0.10 });
      setTimeout(() => beep({ freq: 990, dur: 0.07, type: "triangle", gain: 0.10 }), 90);
    }
  };

  // ===== Game State =====
  const W = 960, H = 720;

  const state = {
    running: false,
    paused: false,
    gameOver: false,
    level: 1,
    score: 0,
    lives: 3,
    mult: 1.0,
    speedMul: 1.0,
    startedOnce: false,
    // feedback
    flashEnabled: true,
    flash: 0,         // 0..1
    shake: 0,         // px
    hitStop: 0,       // seconds
    // input
    keys: new Set(),
    pointerX: null,
    pointerActive: false,
    // time
    lastTs: 0,
    acc: 0,
  };

  const paddle = {
    w: 140,
    h: 16,
    x: W/2,
    y: H - 70,
    vx: 0,
    speed: 820, // px/s
  };

  const ball = {
    r: 9,
    x: W/2,
    y: H - 90,
    vx: 280,
    vy: -420,
    speed: 520, // base target
    stuck: true, // stuck to paddle until start
  };

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  function resetBall(stuck = true) {
    ball.stuck = stuck;
    ball.x = paddle.x;
    ball.y = paddle.y - paddle.h/2 - ball.r - 2;
    // ランダム性は少し。完全ランダムは理不尽。
    const dir = (Math.random() < 0.5 ? -1 : 1);
    ball.vx = 260 * dir;
    ball.vy = -440;
  }

  // ===== Bricks / Levels =====
  const bricks = {
    cols: 11,
    rows: 6,
    pad: 10,
    top: 90,
    left: 60,
    w: 72,
    h: 24,
    list: [],
  };

  function makeLevel(lv) {
    bricks.list.length = 0;
    const rows = bricks.rows + Math.min(2, Math.floor((lv-1)/2));
    const cols = bricks.cols;
    const colors = [
      [0.15, 0.6, 0.95],
      [0.2, 0.9, 0.65],
      [0.95, 0.75, 0.25],
      [0.98, 0.45, 0.55],
      [0.75, 0.55, 0.98],
      [0.35, 0.85, 0.98],
      [0.95, 0.95, 0.95],
    ];
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        // パターン: 無難じゃなく、でも理解はできる
        const mask = (r + lv) % 2 === 0 ? 1 : 0;
        if (mask && (c === 0 || c === cols-1) && r < 2) continue; // 少し抜く
        const hp = 1 + Math.floor((lv-1)/3) + (r >= rows-2 ? 1 : 0);
        const col = colors[(r + lv) % colors.length];
        bricks.list.push({
          x: bricks.left + c * (bricks.w + bricks.pad),
          y: bricks.top + r * (bricks.h + bricks.pad),
          w: bricks.w,
          h: bricks.h,
          hp,
          hpMax: hp,
          col,
          alive: true,
          pop: 0, // pop animation
        });
      }
    }
  }

  // ===== Player-first UX helpers =====
  function announce(msg) {
    ui.liveRegion.textContent = msg;
  }
  function setStatus(title, body) {
    ui.statusTitle.textContent = title;
    ui.statusBody.textContent = body;
    ui.statusCard.style.display = "block";
  }
  function clearStatus() {
    ui.statusCard.style.display = "none";
  }

  // ===== Start / Restart =====
  function restart(all = true) {
    state.running = true;
    state.paused = false;
    state.gameOver = false;
    state.flash = 0;
    state.shake = 0;
    state.hitStop = 0;
    state.mult = 1.0;
    state.speedMul = parseFloat(ui.selSpeed.value || "1.0");
    if (all) {
      state.level = 1;
      state.score = 0;
      state.lives = 3;
    }
    makeLevel(state.level);
    paddle.x = W/2;
    paddle.vx = 0;
    resetBall(true);
    ui.hintCard.style.display = state.startedOnce ? "none" : "block";
    clearStatus();
    syncUI();
    announce("リスタート");
  }

  // ===== Input =====
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (["arrowleft","arrowright","a","d","p","r"," ","space"].includes(k) || e.code === "Space") e.preventDefault();
    state.keys.add(k);
    if (e.code === "Space" || k === " " || k === "space") {
      userStart();
    } else if (k === "p") {
      togglePause();
    } else if (k === "r") {
      restart(false);
    }
  }, { passive: false });

  window.addEventListener("keyup", (e) => {
    state.keys.delete(e.key.toLowerCase());
  });

  // Pointer: mouse/touch
  function pointerToWorld(clientX) {
    const rect = canvas.getBoundingClientRect();
    const nx = (clientX - rect.left) / rect.width;
    return clamp(nx * W, 0, W);
  }

  function onPointerDown(e) {
    state.pointerActive = true;
    const x = (e.touches ? e.touches[0].clientX : e.clientX);
    state.pointerX = pointerToWorld(x);
    userStart();
  }
  function onPointerMove(e) {
    if (!state.pointerActive && !e.touches) return;
    const x = (e.touches ? e.touches[0].clientX : e.clientX);
    state.pointerX = pointerToWorld(x);
  }
  function onPointerUp() {
    state.pointerActive = false;
    state.pointerX = null;
  }

  canvas.addEventListener("mousedown", onPointerDown);
  window.addEventListener("mousemove", onPointerMove);
  window.addEventListener("mouseup", onPointerUp);
  canvas.addEventListener("touchstart", onPointerDown, { passive: false });
  window.addEventListener("touchmove", onPointerMove, { passive: false });
  window.addEventListener("touchend", onPointerUp);

  // ===== UI toggles =====
  ui.togSound.addEventListener("change", () => {
    audioState.enabled = !!ui.togSound.checked;
    if (audioState.enabled) ensureAudio();
  });
  ui.togFlash.addEventListener("change", () => {
    state.flashEnabled = !!ui.togFlash.checked;
  });
  ui.selSpeed.addEventListener("change", () => {
    state.speedMul = parseFloat(ui.selSpeed.value || "1.0");
    syncUI();
  });

  ui.btnRestart.addEventListener("click", () => restart(false));
  ui.btnPause.addEventListener("click", () => togglePause());

  function togglePause() {
    if (!state.running) return;
    state.paused = !state.paused;
    if (state.paused) {
      setStatus("一時停止", "Spaceで再開。今のうちに心を整えろ。");
      announce("一時停止");
    } else {
      clearStatus();
      announce("再開");
      if (audioCtx && audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
    }
  }

  function userStart() {
    if (!state.running) state.running = true;
    state.startedOnce = true;
    ui.hintCard.style.display = "none";
    clearStatus();
    if (state.paused) state.paused = false;
    if (ball.stuck) {
      ball.stuck = false;
      // 最初の一手は気持ちよく。ちょい速め。
      normalizeBallSpeed(ball.speed * 1.02);
      announce("開始");
      // ユーザー操作でオーディオ解禁
      if (audioCtx && audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
    }
  }

  // ===== Physics helpers =====
  function length(vx, vy) { return Math.hypot(vx, vy); }
  function normalizeBallSpeed(target) {
    const sp = length(ball.vx, ball.vy);
    if (sp < 1e-3) return;
    const mul = target / sp;
    ball.vx *= mul;
    ball.vy *= mul;
  }

  function hitFeedback(intensity = 1.0) {
    if (!state.flashEnabled) return;
    state.flash = clamp(state.flash + 0.6 * intensity, 0, 1);
    state.shake = clamp(state.shake + 5 * intensity, 0, 10);
    state.hitStop = clamp(state.hitStop + 0.03 * intensity, 0, 0.09);
  }

  // ===== Collision =====
  function rectCircleCollide(rx, ry, rw, rh, cx, cy, cr) {
    const px = clamp(cx, rx, rx + rw);
    const py = clamp(cy, ry, ry + rh);
    const dx = cx - px, dy = cy - py;
    return (dx*dx + dy*dy) <= cr*cr;
  }

  function resolveBrickCollision(b) {
    // 進行方向からざっくり面を推定。十分、というかこれで気持ちいい。
    const cx = ball.x, cy = ball.y;
    const prevX = cx - ball.vx * (1/60), prevY = cy - ball.vy * (1/60);
    const bx = b.x, by = b.y, bw = b.w, bh = b.h;

    // 前フレーム位置でどこから入ったか推定
    const fromLeft = prevX <= bx - ball.r;
    const fromRight = prevX >= bx + bw + ball.r;
    const fromTop = prevY <= by - ball.r;
    const fromBottom = prevY >= by + bh + ball.r;

    if ((fromLeft && !fromRight) || (fromRight && !fromLeft)) {
      ball.vx *= -1;
    } else if ((fromTop && !fromBottom) || (fromBottom && !fromTop)) {
      ball.vy *= -1;
    } else {
      // 角っぽい。無難に反転
      const dx = (cx - (bx + bw/2)) / (bw/2);
      const dy = (cy - (by + bh/2)) / (bh/2);
      if (Math.abs(dx) > Math.abs(dy)) ball.vx *= -1;
      else ball.vy *= -1;
    }
  }

  function handlePaddleCollision() {
    const rx = paddle.x - paddle.w/2;
    const ry = paddle.y - paddle.h/2;
    if (!rectCircleCollide(rx, ry, paddle.w, paddle.h, ball.x, ball.y, ball.r)) return false;

    // 上方向へ反射。打点で角度を作る。デファクト。
    const hitX = (ball.x - paddle.x) / (paddle.w/2);
    const angle = clamp(hitX, -1, 1) * (Math.PI * 0.36); // 0.36π ≒ 65度
    const sp = Math.max(ball.speed * 0.90, length(ball.vx, ball.vy));
    ball.vx = sp * Math.sin(angle);
    ball.vy = -Math.abs(sp * Math.cos(angle));

    // めり込み補正
    ball.y = ry - ball.r - 0.5;

    // コンボ倍率: 無駄に理不尽にならないよう上限
    state.mult = clamp(state.mult + 0.05, 1.0, 2.0);

    SFX.paddle();
    hitFeedback(0.8);
    return true;
  }

  // ===== Update / Render =====
  function syncUI() {
    ui.score.textContent = String(Math.floor(state.score));
    ui.lives.textContent = String(state.lives);
    ui.level.textContent = String(state.level);
    ui.mult.textContent = state.mult.toFixed(1);
  }

  function nextLevel() {
    state.level += 1;
    state.mult = clamp(state.mult + 0.15, 1.0, 2.0);
    makeLevel(state.level);
    resetBall(true);
    setStatus("レベル " + state.level, "Spaceで開始。テンポは落とすな。");
    announce("レベルアップ");
    SFX.win();
    syncUI();
  }

  function loseLife() {
    state.lives -= 1;
    state.mult = 1.0;
    SFX.lose();
    hitFeedback(1.2);
    if (state.lives <= 0) {
      state.gameOver = true;
      state.paused = true;
      setStatus("ゲームオーバー", "Rでやり直し。苦労は忘れろ、スコアは残る。");
      announce("ゲームオーバー");
    } else {
      resetBall(true);
      setStatus("落下", "残機 " + state.lives + "。Spaceで再開。");
      announce("残機減少");
    }
    syncUI();
  }

  function update(dt) {
    // dt: seconds
    if (!state.running) return;
    if (state.paused) return;

    // speed multiplier
    const sm = state.speedMul;

    // hitstop: 動かさないが、演出は進める
    if (state.hitStop > 0) {
      state.hitStop = Math.max(0, state.hitStop - dt);
      // flash decay still
      state.flash = Math.max(0, state.flash - dt * 2.0);
      state.shake = Math.max(0, state.shake - dt * 20);
      return;
    }

    // Input -> paddle target velocity
    let dir = 0;
    if (state.keys.has("arrowleft") || state.keys.has("a")) dir -= 1;
    if (state.keys.has("arrowright") || state.keys.has("d")) dir += 1;

    const desired = dir * paddle.speed;
    // pointer overrides for player convenience (and market reality)
    if (state.pointerX != null) {
      const dx = state.pointerX - paddle.x;
      paddle.vx = clamp(dx * 10, -paddle.speed * 1.4, paddle.speed * 1.4);
    } else {
      // accel smoothing
      paddle.vx += (desired - paddle.vx) * clamp(dt * 12, 0, 1);
    }
    paddle.x += paddle.vx * dt * sm;
    paddle.x = clamp(paddle.x, paddle.w/2, W - paddle.w/2);

    // Ball
    if (ball.stuck) {
      ball.x = paddle.x;
      ball.y = paddle.y - paddle.h/2 - ball.r - 2;
      // multiplier slowly decays while waiting so idle isn't rewarded
      state.mult = Math.max(1.0, state.mult - dt * 0.12);
      return;
    }

    // keep speed consistent, increase slightly with level
    const targetSpeed = (ball.speed + state.level * 12) * sm;
    normalizeBallSpeed(targetSpeed);

    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;

    // Walls
    if (ball.x - ball.r <= 0) {
      ball.x = ball.r;
      ball.vx *= -1;
      SFX.wall();
      hitFeedback(0.35);
    } else if (ball.x + ball.r >= W) {
      ball.x = W - ball.r;
      ball.vx *= -1;
      SFX.wall();
      hitFeedback(0.35);
    }
    if (ball.y - ball.r <= 0) {
      ball.y = ball.r;
      ball.vy *= -1;
      SFX.wall();
      hitFeedback(0.35);
    }
    if (ball.y - ball.r > H + 40) {
      loseLife();
      return;
    }

    // Paddle collision
    handlePaddleCollision();

    // Bricks collision: check near
    let aliveCount = 0;
    for (const b of bricks.list) {
      if (!b.alive) continue;
      aliveCount++;
      if (rectCircleCollide(b.x, b.y, b.w, b.h, ball.x, ball.y, ball.r)) {
        resolveBrickCollision(b);
        b.hp -= 1;
        b.pop = 1.0;
        SFX.brick();
        hitFeedback(1.0);
        // score
        const base = 120;
        state.score += base * state.mult * (1 + 0.1 * (b.hpMax - 1));
        // Slightly ramp multiplier on brick hit
        state.mult = clamp(state.mult + 0.02, 1.0, 2.0);
        if (b.hp <= 0) {
          b.alive = false;
          // bonus for break
          state.score += 80 * state.mult;
        }
        syncUI();
        break; // 1フレーム多重ヒットは不親切になりやすいので禁止
      }
    }

    // if all cleared
    if (aliveCount === 0) {
      nextLevel();
    }

    // feedback decay
    state.flash = Math.max(0, state.flash - dt * 2.0);
    state.shake = Math.max(0, state.shake - dt * 20);
    // multiplier decays slowly to avoid runaway
    state.mult = Math.max(1.0, state.mult - dt * 0.05);
  }

  function drawBackground() {
    // Subtle grid and vignette. 見やすさ優先。
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.20)";
    ctx.fillRect(0, 0, W, H);

    // grid
    ctx.globalAlpha = 0.22;
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 1;
    const step = 40;
    for (let x = 0; x <= W; x += step) {
      ctx.beginPath();
      ctx.moveTo(x + 0.5, 0);
      ctx.lineTo(x + 0.5, H);
      ctx.stroke();
    }
    for (let y = 0; y <= H; y += step) {
      ctx.beginPath();
      ctx.moveTo(0, y + 0.5);
      ctx.lineTo(W, y + 0.5);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // top gradient band behind bricks
    const g = ctx.createLinearGradient(0, 0, 0, 220);
    g.addColorStop(0, "rgba(125, 211, 252, 0.18)");
    g.addColorStop(1, "rgba(0,0,0,0.0)");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, 260);

    // vignette
    const v = ctx.createRadialGradient(W/2, H/2, 120, W/2, H/2, 560);
    v.addColorStop(0, "rgba(0,0,0,0.0)");
    v.addColorStop(1, "rgba(0,0,0,0.55)");
    ctx.fillStyle = v;
    ctx.fillRect(0, 0, W, H);
    ctx.restore();
  }

  function drawPaddle() {
    const x = paddle.x - paddle.w/2;
    const y = paddle.y - paddle.h/2;

    ctx.save();
    // glow
    ctx.shadowColor = "rgba(125,211,252,0.40)";
    ctx.shadowBlur = 18;
    ctx.fillStyle = "rgba(125,211,252,0.30)";
    roundRect(x, y, paddle.w, paddle.h, 10);
    ctx.fill();

    // body
    ctx.shadowBlur = 0;
    const g = ctx.createLinearGradient(0, y, 0, y + paddle.h);
    g.addColorStop(0, "rgba(255,255,255,0.22)");
    g.addColorStop(1, "rgba(255,255,255,0.08)");
    ctx.fillStyle = g;
    roundRect(x, y, paddle.w, paddle.h, 10);
    ctx.fill();

    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 1;
    roundRect(x + 0.5, y + 0.5, paddle.w - 1, paddle.h - 1, 10);
    ctx.stroke();
    ctx.restore();
  }

  function drawBall() {
    ctx.save();
    ctx.shadowColor = "rgba(255,255,255,0.55)";
    ctx.shadowBlur = 18;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.fill();

    // highlight
    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.arc(ball.x - ball.r*0.35, ball.y - ball.r*0.35, ball.r*0.35, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(125,211,252,0.75)";
    ctx.fill();
    ctx.restore();
  }

  function drawBricks() {
    ctx.save();
    for (const b of bricks.list) {
      if (!b.alive) continue;

      // pop animation
      const pop = b.pop;
      b.pop = Math.max(0, b.pop - 1/60 * 6);
      const scale = 1 + pop * 0.08;
      const cx = b.x + b.w/2;
      const cy = b.y + b.h/2;

      const w = b.w * scale;
      const h = b.h * scale;
      const x = cx - w/2;
      const y = cy - h/2;

      // color based on hp
      const t = b.hp / b.hpMax;
      const [r,g,bl] = b.col;
      const alpha = 0.86;
      const fill = `rgba(${Math.floor(r*255)},${Math.floor(g*255)},${Math.floor(bl*255)},${alpha})`;

      // glow
      ctx.shadowColor = `rgba(${Math.floor(r*255)},${Math.floor(g*255)},${Math.floor(bl*255)},0.35)`;
      ctx.shadowBlur = 14;

      const rr = 9;
      ctx.fillStyle = fill;
      roundRect(x, y, w, h, rr);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.lineWidth = 1;
      roundRect(x + 0.5, y + 0.5, w - 1, h - 1, rr);
      ctx.stroke();

      // hp pip
      if (b.hpMax > 1) {
        ctx.fillStyle = "rgba(0,0,0,0.25)";
        ctx.fillRect(x + 10, y + h - 8, w - 20, 3);
        ctx.fillStyle = "rgba(255,255,255,0.65)";
        ctx.fillRect(x + 10, y + h - 8, (w - 20) * t, 3);
      }
    }
    ctx.restore();
  }

  function drawCenterText() {
    if (!state.running) return;
    if (state.paused) return;

    if (ball.stuck && !state.gameOver) {
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.86)";
      ctx.font = "700 28px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Space / クリックで開始", W/2, H/2 - 10);

      ctx.fillStyle = "rgba(255,255,255,0.62)";
      ctx.font = "500 14px system-ui, sans-serif";
      ctx.fillText("不親切を作るくらいなら、ここで始め方を出す。以上。", W/2, H/2 + 18);
      ctx.restore();
    }
  }

  function drawOverlay() {
    // flash
    if (state.flashEnabled && state.flash > 0.001) {
      ctx.save();
      ctx.globalAlpha = state.flash * 0.45;
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, W, H);
      ctx.restore();
    }
  }

  function roundRect(x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  function render() {
    // screen shake
    const sx = (state.flashEnabled ? (Math.random() * 2 - 1) * state.shake : 0);
    const sy = (state.flashEnabled ? (Math.random() * 2 - 1) * state.shake : 0);

    ctx.save();
    ctx.clearRect(0, 0, W, H);
    ctx.translate(sx, sy);

    drawBackground();
    drawBricks();
    drawPaddle();
    drawBall();
    drawCenterText();

    ctx.restore();
    drawOverlay();
  }

  // ===== Main loop: fixed timestep =====
  const STEP = 1 / 60;
  function frame(ts) {
    if (!state.lastTs) state.lastTs = ts;
    const dt = Math.min(0.05, (ts - state.lastTs) / 1000);
    state.lastTs = ts;
    state.acc += dt;

    // 小細工より「動く」。ただそれだけで価値がある。
    while (state.acc >= STEP) {
      update(STEP);
      state.acc -= STEP;
    }
    render();
    requestAnimationFrame(frame);
  }

  // ===== Init =====
  function init() {
    state.flashEnabled = !!ui.togFlash.checked;
    audioState.enabled = !!ui.togSound.checked;
    state.speedMul = parseFloat(ui.selSpeed.value || "1.0");

    restart(true);
    setStatus("準備完了", "Spaceで開始。やる気を待つな。入力しろ。");
    state.paused = true;
    requestAnimationFrame(frame);
  }

  init();
})();
</script>
</body>
</html>
